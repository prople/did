use multibase::{self, Base::Base58Btc};
use multihash::Multihash;
use rst_common::with_cryptography::blake3;

use crate::types::{DIDError, ToJSON, BLAKE3_HASH_CODE};

/// `generate_from_json` used to generate the `HashLink` from given data that implement [`ToJSON`] trait
///
/// Following standard algorithm, the given data in json will be hashed using `BLAKE3` hash function algorithm
/// then structure it with `Multihash` and for the final output encode the multihash using `Multibase::Base58btc`
/// format
pub fn generate_from_json(data: impl ToJSON) -> Result<String, DIDError> {
    let jsondata = data.to_json()?;
    let hashed_json = blake3::hash(jsondata.to_string().as_bytes());
    let output_hash = Multihash::<32>::wrap(BLAKE3_HASH_CODE, hashed_json.as_bytes())
        .map_err(|err| DIDError::GenerateHashLinkError(err.to_string()))?;

    let base58_encoded = multibase::encode(Base58Btc, output_hash.to_bytes());
    Ok(base58_encoded)
}

/// `verify_from_json` used to verify given data in json and compare it with given encoded value
///
/// The logic is recalculate the `Multihash` and compare it's bytes with the decoded bytes from given
/// `encoded` value. The decoded data will check if given encoded string value follow the `Multibase::Base58btc` format
/// or not, if it's valid, then start to compare the generated bytes between decoded and generated value
/// from given data in json
pub fn verify_from_json(data: impl ToJSON, encoded: String) -> Result<(), DIDError> {
    let jsondata = data.to_json()?;
    let hashed_json = blake3::hash(jsondata.to_string().as_bytes());

    let (decoded_base, decoded_bytes) = multibase::decode(encoded.clone())
        .map_err(|err| DIDError::HashLinkError(err.to_string()))?;

    if decoded_base != Base58Btc {
        return Err(DIDError::HashLinkError(
            "unknown base encoded type".to_string(),
        ));
    }

    let calculate_multihash = Multihash::<32>::wrap(BLAKE3_HASH_CODE, hashed_json.as_bytes())
        .map_err(|err| DIDError::HashLinkError(err.to_string()))?;

    if decoded_bytes != calculate_multihash.to_bytes() {
        return Err(DIDError::HashLinkError("invalid hashlink".to_string()));
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use rst_common::standard::serde::{self, Deserialize, Serialize};
    use rst_common::standard::serde_json;

    use crate::types::JSONValue;

    #[derive(Deserialize, Serialize, Clone, Debug)]
    #[serde(crate = "self::serde")]
    struct FakeMessage {
        message: String,
    }

    impl ToJSON for FakeMessage {
        fn to_json(&self) -> Result<JSONValue, DIDError> {
            let jsonstr = serde_json::to_string(self)
                .map_err(|err| DIDError::GenerateJSONError(err.to_string()))?;
            Ok(JSONValue::from(jsonstr))
        }
    }

    #[test]
    fn test_generate_hl_from_json() {
        let msg = FakeMessage {
            message: "hello world".to_string(),
        };
        let hl = generate_from_json(msg);
        assert!(!hl.is_err());

        let encoded = hl.unwrap();
        assert!(encoded.contains("z"))
    }

    #[test]
    fn test_verify_hl_from_json() {
        let msg = FakeMessage {
            message: "hello world".to_string(),
        };
        let hl = generate_from_json(msg.clone());
        assert!(!hl.is_err());

        let encoded = hl.unwrap();
        let verified_hl = verify_from_json(msg, encoded.clone());
        assert!(!verified_hl.is_err())
    }

    #[test]
    fn test_verify_hl_invalid() {
        let msg = FakeMessage {
            message: "hello world".to_string(),
        };

        let msg_invalid = FakeMessage {
            message: "invalid".to_string(),
        };

        let hl = generate_from_json(msg.clone());
        assert!(!hl.is_err());

        let encoded = hl.unwrap();
        let verified_hl = verify_from_json(msg_invalid, encoded.clone());
        assert!(verified_hl.is_err());
        assert!(matches!(
            verified_hl.clone().unwrap_err(),
            DIDError::HashLinkError(_)
        ));
        assert_eq!(
            "error hashlink: invalid hashlink".to_owned(),
            verified_hl.unwrap_err().to_string()
        )
    }
}
